vfp_vep_callback(const struct sess *sp, ssize_t l, enum vgz_flag flg)\n{\n\tstruct vef_priv *vef;\n\tsize_t dl, px;\n\tconst void *dp;\n\tint i;\n\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\tvef = sp->wrk->vef_priv;\n\tCHECK_OBJ_NOTNULL(vef, VEF_MAGIC);\n\tassert(l >= 0);\n\n\tif (vef->error) {\n\t\tvef->tot += l;\n\t\treturn (vef->tot);\n\t}\n\n\t/*\n\t * l == 0 is valid when 'flg' calls for action, but in the\n\t * normal case we can just ignore a l==0 request.\n\t * (It would cause Z_BUF_ERROR anyway)\n\t */\n\tif (l == 0 && flg == VGZ_NORMAL)\n\t\treturn (vef->tot);\n\n\tdo {\n\t\tpx = vef->npend;\n\t\tif (l < px)\n\t\t\tpx = l;\n\t\tif (px != 0) {\n\t\t\tVGZ_Ibuf(vef->vgz, vef->pending, px);\n\t\t\tl -= px;\n\t\t} else {\n\t\t\tVGZ_Ibuf(vef->vgz, vef->bufp, l);\n\t\t\tvef->bufp += l;\n\t\t\tl = 0;\n\t\t}\n\t\tdo {\n\t\t\tif (VGZ_ObufStorage(sp, vef->vgz)) {\n\t\t\t\tvef->error = errno;\n\t\t\t\tvef->tot += l;\n\t\t\t\treturn (vef->tot);\n\t\t\t}\n\t\t\ti = VGZ_Gzip(vef->vgz, &dp, &dl, flg);\n\t\t\tvef->tot += dl;\n\t\t\tsp->obj->len += dl;\n\t\t} while (!VGZ_IbufEmpty(vef->vgz) ||\n\t\t    (flg != VGZ_NORMAL && VGZ_ObufFull(vef->vgz)));\n\t\tif (px != 0) {\n\t\t\tmemmove(vef->pending, vef->pending + px,\n\t\t\t    vef->npend - px);\n\t\t\tvef->npend -= px;\n\t\t}\n\t} while (l > 0);\n\tif (flg == VGZ_FINISH)\n\t\tassert(i == 1);\t\t\t/* XXX */\n\telse\n\t\tassert(i == 0);\t\t\t/* XXX */\n\treturn (vef->tot);\n}